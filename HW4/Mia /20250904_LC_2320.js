class Solution {
    public int countHousePlacements(int n) {
     final int MOD = 1000000007;
// final 表示常量，后面不能再修改，语义清晰：这是一个全局固定的模数。
// int 足够存储 1e9+7（远小于 2^31 - 1），所以不需要写 long。
        long[][] dp = new long[n + 1][2];
// 创建一个二维数组 dp，大小为 (n+1) x 2，类型用 long：
// 用 n+1 是为了方便用 1-based（从 1 开始） 索引（代码里使用了 dp[1]）。
// dp[i][0] 表示长度为 i 时、第 i 个位置为空（不放房子） 的不同放置方案数。
// dp[i][1] 表示长度为 i 时、第 i 个位置放房子 的不同放置方案数。
// 用 long 是因为中间值（尤其最后平方之前）可能接近 1e9 的数量级，计算时更安全。
        dp[1][0] = 1;
        dp[1][1] = 1;
// 设定初始条件（base cases）：对于只有 1 个格子（i = 1）：
// dp[1][0] = 1：第 1 个位置为空，只有一种情况（.）。
// dp[1][1] = 1：第 1 个位置放房子，也只有一种情况（H）
// （所以单侧长度为 1 的总方案数是 1 + 1 = 2。）
        for (int i = 2; i <= n; i++) {
            dp[i][0] = (dp[i - 1][0] + dp[i - 1][1]) % MOD;
//计算 dp[i][0]（第 i 位不放房子）的方案数：
//如果第 i 位不放房子，那么第 i-1 位可以是放也可以是不放，
//因而方案数为 dp[i-1][0] + dp[i-1][1]。最后对 MOD 取模以保持数值不溢出。
            dp[i][1] = dp[i - 1][0] % MOD;
//计算 dp[i][1]（第 i 位放房子）的方案数：
//若第 i 位放房子，则第 i-1 位 必须为空（不能相邻两房子），
//所以只有 dp[i-1][0] 种情况。对 MOD 取模（写上取模是为了统一风格，
//dp[i-1][0] 本身已被模过）。
        }
        long res = (dp[n][0] + dp[n][1]) % MOD;
//dp[n][0] 是以空结尾的方案数，dp[n][1] 是以房子结尾的方案数，两者相加即为所有可能。
        return (int)((res * res) % MOD);
    }
}
// 把单侧方案数 res 平方（因为左右两边独立，左右组合数 = 左侧方案数 × 右侧方案数），再对 MOD 取模。
// res * res 在类型上是 long * long，结果仍是 long，再 % MOD 得到 long，最后强制转换成 int 返回（LeetCode 方法签名要求返回 int）。
// 注意：用 long 来保存和计算平方是为了避免 int 溢出。
