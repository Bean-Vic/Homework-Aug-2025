name: PR Structure Check
on:
  pull_request:
    types: [opened, edited, synchronize, ready_for_review]

permissions:
  pull-requests: write
  contents: read

jobs:
  structure:
    name: PR Structure Check
    if: ${{ !github.event.pull_request.draft }}
    runs-on: ubuntu-latest
    steps:
      - name: Check PR structure, note.md, and audio file
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request || {};
            const repo = context.repo;
            const title = pr.title || "";
            const headSha = pr.head && pr.head.sha ? pr.head.sha : "";
            const MARK = "<!-- pr-structure-lint -->";

            async function upsert(lines){
              const body = [MARK].concat(lines).join("\n");
              const resp = await github.rest.issues.listComments({ owner: repo.owner, repo: repo.repo, issue_number: pr.number, per_page: 100 });
              const ex = (resp.data || []).find(c => c.body && c.body.indexOf(MARK) !== -1);
              if (ex) { await github.rest.issues.updateComment({ owner: repo.owner, repo: repo.repo, comment_id: ex.id, body }); }
              else   { await github.rest.issues.createComment({ owner: repo.owner, repo: repo.repo, issue_number: pr.number, body }); }
            }
            async function cleanup(){
              const resp = await github.rest.issues.listComments({ owner: repo.owner, repo: repo.repo, issue_number: pr.number, per_page: 100 });
              const ex = (resp.data || []).find(c => c.body && c.body.indexOf(MARK) !== -1);
              if (ex) { await github.rest.issues.deleteComment({ owner: repo.owner, repo: repo.repo, comment_id: ex.id }); }
            }
            async function safeUpsert(lines){ try{ await upsert(lines); }catch(e){ core.warning("Cannot comment: " + (e.message||e)); } }
            async function safeCleanup(){ try{ await cleanup(); }catch(e){} }
            async function fail(lines){ await safeUpsert(lines); core.setFailed("PR structure invalid"); }

            // 从标题解析整数作业号
            const m = title.match(/HW(0|[1-9]\d*)/i);
            if (!m) {
              await fail([
                "### 🚫 无法解析作业号",
                "",
                "当前标题：`" + title + "`",
                "请先把标题改成 `HW{整数} - {Name}`。"
              ]);
              return;
            }
            const num = Number(m[1]);

            // 拉取 PR 文件列表
            const files = [];
            let page = 1;
            while (true) {
              const resp = await github.rest.pulls.listFiles({ owner: repo.owner, repo: repo.repo, pull_number: pr.number, per_page: 100, page });
              const data = resp.data || [];
              for (const it of data) files.push(it);
              if (data.length < 100) break;
              page += 1;
            }
            if (files.length === 0) {
              await fail([
                "### 🚫 未检测到任何文件改动",
                "",
                "请在 `HW" + num + "/{NAME_FOLDER}/` 下提交作业文件，并包含 `note.md` 与一个音频文件。"
              ]);
              return;
            }

            // 仅检查非删除改动
            const active = files.filter(f => ["added","modified","renamed","copied","changed"].indexOf(f.status||"") !== -1);

            const folders = new Set();
            const wrongHwFiles = [];
            const outsideHwFiles = [];
            const noNameFolderFiles = [];
            const pathStartRe = new RegExp("^HW" + num + "/([^/]+)/");

            for (const f of active) {
              const p = f.filename || "";
              const oh = p.match(/^HW(\d+)\//i);
              if (oh && Number(oh[1]) !== num) { wrongHwFiles.push(p); continue; }
              if (p.indexOf("HW" + num + "/") !== 0) { outsideHwFiles.push(p); continue; }
              const mm = p.match(pathStartRe);
              if (!mm) { noNameFolderFiles.push(p); continue; }
              folders.add(mm[1]);
            }

            if (wrongHwFiles.length || outsideHwFiles.length || noNameFolderFiles.length) {
              const lines = [];
              lines.push("### 🚫 变更路径不符合规范");
              if (wrongHwFiles.length) { lines.push("**错误作业目录**："); wrongHwFiles.forEach(p=>lines.push("- `"+p+"`")); }
              if (outsideHwFiles.length){ lines.push("**不在 `HW"+num+"/` 下**："); outsideHwFiles.forEach(p=>lines.push("- `"+p+"`")); }
              if (noNameFolderFiles.length){ lines.push("**缺少 {NAME_FOLDER} 这一层**："); noNameFolderFiles.forEach(p=>lines.push("- `"+p+"`")); }
              lines.push("");
              lines.push("**要求：** 所有文件必须位于 `HW" + num + "/{NAME_FOLDER}/**`。");
              await fail(lines);
              return;
            }

            if (folders.size !== 1) {
              await fail([
                "### 🚫 检测到多个 {NAME_FOLDER}",
                "",
                "当前检测到：" + "`" + Array.from(folders).join("`, `") + "`"
              ]);
              return;
            }

            const folder = Array.from(folders)[0];

            // 检查 note.md
            let hasNote = true;
            try {
              await github.rest.repos.getContent({
                owner: repo.owner, repo: repo.repo,
                path: "HW" + num + "/" + folder + "/note.md",
                ref: headSha
              });
            } catch (e) { hasNote = false; }

            // 检查音频文件（白名单扩展名）
            const audioExts = [".mp3",".m4a",".wav",".flac",".aac",".ogg",".wma",".mp4",".mpeg",".webm"];
            let hasAudio = false;
            try {
              const resp = await github.rest.repos.getContent({
                owner: repo.owner,
                repo: repo.repo,
                path: "HW" + num + "/" + folder,
                ref: headSha
              });
              const entries = Array.isArray(resp.data) ? resp.data : [];
              for (const entry of entries) {
                const name = entry.name.toLowerCase();
                if (audioExts.some(ext => name.endsWith(ext))) {
                  hasAudio = true;
                  break;
                }
              }
            } catch (e) { /* ignore */ }

            if (!hasNote || !hasAudio) {
              const lines = [];
              lines.push("### 🚫 缺少必需文件");
              if (!hasNote) lines.push("- 未检测到 `note.md`");
              if (!hasAudio) lines.push("- 未检测到任何音频文件（扩展名必须是 " + audioExts.join(", ") + " 之一）");
              lines.push("");
              lines.push("**要求：** 在 `HW" + num + "/" + folder + "/` 下必须同时存在 `note.md` 和至少一个音频文件。");
              await fail(lines);
              return;
            }

            await safeCleanup();
            core.info("✅ Structure OK: HW" + num + "/" + folder);
