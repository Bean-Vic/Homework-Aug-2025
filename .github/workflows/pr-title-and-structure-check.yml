name: PR Title & Folder Structure Check (PR)

on:
  pull_request:
    types: [opened, edited, synchronize, ready_for_review]

permissions:
  pull-requests: write   # è¯„è®ºéœ€è¦ï¼›fork PR æ—¶å³ä½¿å†™äº†ä¹Ÿå¯èƒ½åªæœ‰åªè¯»ï¼Œä»£ç å·²å®¹é”™
  contents: read

jobs:
  lint:
    if: ${{ !github.event.pull_request.draft }}  # è‰ç¨¿è¦æ ¡éªŒå°±åˆ è¿™ä¸€è¡Œ
    runs-on: ubuntu-latest
    steps:
      - name: Validate PR (title + folder + note.md)
        uses: actions/github-script@v7
        with:
          script: |
            // ---- context ----
            const pr = context.payload.pull_request;
            const repo = context.repo;
            const title = pr && pr.title ? pr.title : "";
            const headSha = pr && pr.head && pr.head.sha ? pr.head.sha : "";

            // ---- helpers: sticky comment upsert/cleanup (å¸¦æƒé™å®¹é”™) ----
            const MARK = "<!-- pr-hw-structure-lint -->";

            async function upsert(bodyLines) {
              const body = [MARK].concat(bodyLines).join("\n");
              const commentsResp = await github.rest.issues.listComments({
                owner: repo.owner, repo: repo.repo, issue_number: pr.number, per_page: 100
              });
              const existing = (commentsResp.data || []).find(c => c.body && c.body.indexOf(MARK) !== -1);
              if (existing) {
                await github.rest.issues.updateComment({
                  owner: repo.owner, repo: repo.repo, comment_id: existing.id, body
                });
              } else {
                await github.rest.issues.createComment({
                  owner: repo.owner, repo: repo.repo, issue_number: pr.number, body
                });
              }
            }
            async function cleanup() {
              const commentsResp = await github.rest.issues.listComments({
                owner: repo.owner, repo: repo.repo, issue_number: pr.number, per_page: 100
              });
              const existing = (commentsResp.data || []).find(c => c.body && c.body.indexOf(MARK) !== -1);
              if (existing) {
                await github.rest.issues.deleteComment({
                  owner: repo.owner, repo: repo.repo, comment_id: existing.id
                });
              }
            }
            async function safeUpsert(lines) {
              try { await upsert(lines); }
              catch (e) { core.warning("No permission to write PR comment; skipping. " + (e.message || e)); }
            }
            async function safeCleanup() {
              try { await cleanup(); }
              catch (e) { /* ignore */ }
            }
            async function fail(lines) {
              await safeUpsert(lines);
              core.setFailed("PR title/folder structure check failed");
            }

            // ---- 1) title check ----
            const titleRe = /^HW(0|[1-9]|1[0-9]|20)\s*-\s*\S.*$/i; // case-insensitive
            if (!titleRe.test(title)) {
              await fail([
                "### ğŸš« PR æ ‡é¢˜æ ¼å¼é”™è¯¯",
                "",
                "ä½ çš„æ ‡é¢˜ï¼š`" + title + "`",
                "",
                "**è¦æ±‚æ ¼å¼**ï¼š`HW{#} - {Name}`ï¼ˆå¤§å°å†™ä¸æ•æ„Ÿï¼‰",
                "- `#` å¿…é¡»æ˜¯ 0..20 çš„æ•´æ•°",
                "- ä¸­é—´è¦æœ‰è¿å­—ç¬¦ `-`ï¼ˆä¸¤ä¾§å¯æœ‰ç©ºæ ¼ï¼‰",
                "- `{Name}` è‡³å°‘åŒ…å«ä¸€ä¸ªéç©ºç™½å­—ç¬¦",
                "",
                "**æ­£ç¡®ç¤ºä¾‹**ï¼š",
                "- `HW0 - Vincent`",
                "- `HW3 - Zoey`",
                "- `HW20 - Performance tuning`",
                "",
                "**ä¸åˆæ ¼ç¤ºä¾‹**ï¼š",
                "- `hw3`ï¼ˆç¼ºå°‘è¿å­—ç¬¦å’Œåå­—ï¼‰",
                "- `HW21 - test`ï¼ˆæ•°å­—è¶…å‡ºèŒƒå›´ï¼‰",
                "- `HW3- `ï¼ˆç¼ºå°‘åå­—éƒ¨åˆ†ï¼‰"
              ]);
              return;
            }

            const numMatch = title.match(/HW(0|[1-9]|1[0-9]|20)/i);
            const num = numMatch ? Number(numMatch[1]) : NaN;

            // ---- 2) list PR files (paginate) ----
            const files = [];
            let page = 1;
            while (true) {
              const resp = await github.rest.pulls.listFiles({
                owner: repo.owner, repo: repo.repo, pull_number: pr.number, per_page: 100, page
              });
              const data = resp.data || [];
              for (const it of data) files.push(it);
              if (data.length < 100) break;
              page += 1;
            }
            if (files.length === 0) {
              await fail([
                "### ğŸš« æ²¡æœ‰æ£€æµ‹åˆ°ä»»ä½•æ–‡ä»¶æ”¹åŠ¨",
                "",
                "è¯·åœ¨ `HW" + num + "/{NAME_FOLDER}/` ä¸‹æäº¤ä½œä¸šæ–‡ä»¶ï¼Œå¹¶ä¸”åŒ…å« `note.md`ã€‚"
              ]);
              return;
            }

            // åªå…³å¿ƒéåˆ é™¤æ”¹åŠ¨
            const active = files.filter(f => {
              const st = f.status || "";
              return st === "added" || st === "modified" || st === "renamed" || st === "copied" || st === "changed";
            });

            // ---- 3) path checks ----
            const folders = new Set();
            let offending = null;
            let wrongHw = null;

            const pathStartRe = new RegExp("^HW" + num + "/([^/]+)/");

            for (const f of active) {
              const p = f.filename || "";

              // å…¶å®ƒä½œä¸šå·ç›®å½• â†’ å¤±è´¥
              const mOther = p.match(/^HW(\d+)\//i);
              if (mOther && Number(mOther[1]) !== num) { wrongHw = p; break; }

              if (p.indexOf("HW" + num + "/") !== 0) { offending = p; break; }
              const m = p.match(pathStartRe);
              if (!m) { offending = p; break; }
              folders.add(m[1]);
            }

            if (wrongHw) {
              await fail([
                "### ğŸš« ä½œä¸šå·ä¸ä¸€è‡´",
                "",
                "æ ‡é¢˜ä¸­çš„ä½œä¸šå·ï¼š`HW" + num + "`",
                "ä½†æ£€æµ‹åˆ°å…¶ä»–ç›®å½•ï¼š`" + wrongHw + "`",
                "",
                "**è¦æ±‚ï¼š** åªèƒ½æ”¹åŠ¨ `HW" + num + "/{NAME_FOLDER}/` ä¸‹çš„æ–‡ä»¶ã€‚",
                "âœ… ç¤ºä¾‹ï¼š`HW" + num + "/Vincent/note.md`"
              ]);
              return;
            }
            if (offending) {
              await fail([
                "### ğŸš« å˜æ›´è·¯å¾„ä¸ç¬¦åˆè§„èŒƒ",
                "",
                "æ–‡ä»¶ï¼š`" + offending + "`",
                "",
                "**è¦æ±‚ï¼š** æ‰€æœ‰æ”¹åŠ¨æ–‡ä»¶å¿…é¡»ä½äº `HW" + num + "/{NAME_FOLDER}/` ç›®å½•ä¸‹ã€‚",
                "âœ… æ­£ç¡®ç¤ºä¾‹ï¼š`HW" + num + "/Vincent/note.md`ã€`HW" + num + "/Vincent/å½•éŸ³.mp4`",
                "âŒ é”™è¯¯ç¤ºä¾‹ï¼š`HW" + num + "/note.md`ã€`HW" + num + "/question.js`"
              ]);
              return;
            }
            if (folders.size !== 1) {
              await fail([
                "### ğŸš« æ£€æµ‹åˆ°å¤šä¸ª {NAME_FOLDER}",
                "",
                "å½“å‰æ£€æµ‹åˆ°ï¼š`" + Array.from(folders).join("`, `") + "`",
                "",
                "**è¦æ±‚ï¼š** æ¯ä¸ª PR åªèƒ½æäº¤ä¸€ä¸ªä½œä¸šæ–‡ä»¶å¤¹ã€‚"
              ]);
              return;
            }

            const folder = Array.from(folders)[0];

            // ---- 4) note.md must exist at head SHA ----
            try {
              await github.rest.repos.getContent({
                owner: repo.owner, repo: repo.repo,
                path: "HW" + num + "/" + folder + "/note.md",
                ref: headSha
              });
            } catch (e) {
              await fail([
                "### ğŸš« ç¼ºå°‘å¿…éœ€æ–‡ä»¶ note.md",
                "",
                "æœªæ£€æµ‹åˆ°ï¼š`HW" + num + "/" + folder + "/note.md`ï¼ˆæŒ‰å½“å‰ PR å¤´éƒ¨æäº¤ï¼‰",
                "",
                "**è¦æ±‚ï¼š** åœ¨ä½ çš„ä½œä¸šæ–‡ä»¶å¤¹ä¸­æ·»åŠ  `note.md`ï¼ˆåŒºåˆ†å¤§å°å†™ï¼‰ã€‚"
              ]);
              return;
            }

            // ---- success ----
            await safeCleanup();
            core.info("OK: HW" + num + "/" + folder);
